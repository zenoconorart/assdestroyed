<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Emoji Asteroids</title>
<style>
canvas {
    background: black;
    display: block;
    margin: 0 auto;
}
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const shipEmoji = 'üçÜ'; // eggplant
const bulletEmoji = 'üíß'; // water droplet
const asteroidEmoji = 'üçë'; // peach
// Tunable game constants (slightly slower overall)
const TURN_SPEED = 0.05;
const ACCELERATION = 0.05;
const BULLET_SPEED = 3;
const SLOWDOWN_FACTOR = 0.95; // when holding the down arrow
const ASTEROID_MIN_SPEED = 0.5;
const ASTEROID_MAX_SPEED = 1.2;
let score = 0;
function spawnAsteroid() {
  const x = Math.random() * canvas.width;
  const y = Math.random() * canvas.height;
  asteroids.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed });
for(let i=0;i<5;i++) spawnAsteroid();
  ship.x = canvas.width/2;
  ship.y = canvas.height/2;
  ship.vx = ship.vy = 0;
  ship.angle = 0;
  bullets.length = 0;
  asteroids.length = 0;
  for(let i=0;i<5;i++) spawnAsteroid();
    if(gameOver || levelComplete){
  if(gameOver || waiting || levelComplete) return;
    if(!ship.shootCooldown) {
      bullets.push({ x: ship.x, y: ship.y, vx: Math.cos(ship.angle) * BULLET_SPEED, vy: Math.sin(ship.angle) * BULLET_SPEED });
      ship.shootCooldown = 10;
    if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height) bullets.splice(i,1);
      if(Math.hypot(a.x-b.x,a.y-b.y)<20){
        explosions.push({x:a.x, y:a.y, life:20});
    if(Math.hypot(a.x-ship.x,a.y-ship.y)<20){
    levelComplete=true;
    waiting=true;
  asteroids.forEach(a=>{ctx.fillText(asteroidEmoji,a.x,a.y);});
    ctx.fillStyle = 'brown';
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, 20 - ex.life, 0, Math.PI*2);
    ctx.fill();
  ctx.fillText('Score: '+score,10,30);
  if(levelComplete){
    if(!ship.shootCooldown && burstCount < BURST_LIMIT) {
      bullets.push({
        x: ship.x,
        y: ship.y,
        vx: Math.cos(ship.angle) * BULLET_SPEED,
        vy: Math.sin(ship.angle) * BULLET_SPEED
      });
      playShootSound();
      ship.shootCooldown = 15;
      burstCount++;
    }
  } else {
    burstCount = 0;
  }
  if(ship.shootCooldown>0) ship.shootCooldown--;
  ship.x = (ship.x + ship.vx + canvas.width) % canvas.width;
  ship.y = (ship.y + ship.vy + canvas.height) % canvas.height;
  bullets.forEach((b,i)=>{
    b.x += b.vx;
    b.y += b.vy;
    if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height) bullets.splice(i,1);
  });
  for(let ai=asteroids.length-1; ai>=0; ai--){
    const a = asteroids[ai];
    a.x = (a.x+a.vx+canvas.width)%canvas.width;
    a.y = (a.y+a.vy+canvas.height)%canvas.height;
    const radius = 20 * (a.size || 1);
    for(let bi=bullets.length-1; bi>=0; bi--){
      const b = bullets[bi];
      if(Math.hypot(a.x-b.x,a.y-b.y)<radius){
        bullets.splice(bi,1);
        asteroids.splice(ai,1);
        if(level===2 && a.size===2){
          spawnAsteroid(1,a.x,a.y);
          spawnAsteroid(1,a.x,a.y);
        } else if(level===3){
          if(a.size===3){
            spawnAsteroid(2,a.x,a.y);
            spawnAsteroid(2,a.x,a.y);
            spawnAsteroid(2,a.x,a.y);
          } else if(a.size===2){
            spawnAsteroid(1,a.x,a.y);
            spawnAsteroid(1,a.x,a.y);
          }
        }
        playFartSound();
        score++;
        const frags=[];
        for(let i=0;i<5;i++){
          const ang=Math.random()*Math.PI*2;
          const spd=1+Math.random()*2;
          frags.push({x:a.x,y:a.y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd});
        }
        explosions.push({life:20,frags});
        break;
      }
    }
    if(Math.hypot(a.x-ship.x,a.y-ship.y)<radius){
      asteroids.splice(ai,1);
      playerHit();
    }
  }
  explosions.forEach((ex,i)=>{
    ex.life--;
    ex.frags.forEach(f=>{f.x+=f.vx; f.y+=f.vy;});
    if(ex.life<=0) explosions.splice(i,1);
  });
  if(!levelComplete && asteroids.length===0){
    if(level===3){
      gameComplete=true;
      stopMusic();
      playVictoryJingle();
  ctx.fillText('Score: '+score+'  Level: '+level+'  Time: '+gameTime.toFixed(1)+'s',10,30);
      const t = s.time!==undefined ? s.time.toFixed(1)+'s' : '?';
      ctx.fillText(`${i+1}. ${s.name} - ${t}`,canvas.width/2,canvas.height/2+30*(i+1));
      waiting=true;
    }
    if(!scoreEntered){
      ctx.fillText('Game complete - press Enter',canvas.width/2,canvas.height/2-40);
    } else {
      ctx.fillText('Press Enter to restart',canvas.width/2,canvas.height/2-40);
    }
}
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.globalAlpha = 1;
  stars.forEach(s=>{
    const alpha = 0.5 + 0.5*Math.sin(s.phase);
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillRect(s.x, s.y, 2, 2);
  });
  ctx.fillStyle='white';
  ctx.font='30px serif';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  bullets.forEach(b=>{ctx.fillText(bulletEmoji,b.x,b.y);});
  asteroids.forEach(a=>{
    ctx.font = `${30*(a.size||1)}px serif`;
    ctx.fillText(a.emoji || asteroidEmoji, a.x, a.y);
  });
  ctx.font='20px serif';
  explosions.forEach(ex=>{
    ctx.save();
    ctx.globalAlpha = ex.life/20;
    ex.frags.forEach(f=>{
      ctx.fillText('üí©', f.x, f.y);
    });
    ctx.restore();
  });
  ctx.save();
  ctx.translate(ship.x,ship.y);
  ctx.rotate(ship.angle);
  ctx.font='30px serif';
  ctx.fillText(shipEmoji,0,0);
  ctx.restore();
  ctx.fillStyle='white';
  ctx.textAlign='left';
  ctx.fillText('Score: '+score+'  Level: '+level+'  Time: '+gameTime.toFixed(1)+'s',10,30);
  ctx.textAlign='right';
  ctx.fillText(shipEmoji.repeat(lives),canvas.width-10,30);
  if(gameComplete){
    ctx.textAlign='center';
    ctx.fillText('Game complete - press Enter',canvas.width/2,canvas.height/2-40);
    ctx.fillText('Scoreboard:',canvas.width/2,canvas.height/2);
    scoreboard.forEach((s,i)=>{
      const t = s.time!==undefined ? s.time.toFixed(1)+'s' : '?';
      ctx.fillText(`${i+1}. ${s.name} - ${t}`,canvas.width/2,canvas.height/2+30*(i+1));
    });
  } else if(levelComplete){
    ctx.textAlign='center';
    ctx.fillText('Level complete - press Enter',canvas.width/2,canvas.height/2);
  } else if(waiting){
    ctx.textAlign='center';
    ctx.fillText('Press Enter to continue',canvas.width/2,canvas.height/2);
  }
  if(gameOver){
    ctx.textAlign='center';
    ctx.fillText('Game Over - press Enter',canvas.width/2,canvas.height/2);
  }
}
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
