<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Emoji Asteroids</title>
<style>
canvas {
    background: black;
    display: block;
    margin: 0 auto;
}
button {
    position: absolute;
    top: 8px;
    right: 8px;
    font-size: 20px;
    background: transparent;
    border: none;
    cursor: pointer;
}
</style>
</head>
<body>
<button id="muteButton">ðŸ”•</button>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const muteBtn = document.getElementById('muteButton');
const shipEmoji = 'ðŸ†'; // eggplant
const bulletEmoji = 'ðŸ’§'; // water droplet
const asteroidEmoji = 'ðŸ‘'; // peach
// Audio setup
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playShootSound(){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.value = 600;
  gain.gain.value = 0.1;
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.1);
}
function playCrashSound(){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'sawtooth';
  osc.frequency.value = 80;
  gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.5);
}
function playFartSound(){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'triangle';
  osc.frequency.setValueAtTime(120, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 0.3);
  gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.3);
}
const engineOsc = audioCtx.createOscillator();
const engineGain = audioCtx.createGain();
engineOsc.type = 'sine';
engineGain.gain.value = 0;
engineOsc.connect(engineGain).connect(audioCtx.destination);
engineOsc.start();
// background jingle (slightly softer)
const musicNotes = [
  {freq: 440, dur: 0.4},
  {freq: 554, dur: 0.4},
  {freq: 659, dur: 0.4},
  {freq: 880, dur: 0.4}
];
let musicPlaying = false;
let musicTimeout = null;
const musicOscs = [];
function scheduleMusic(){
  if(!musicPlaying) return;
  let start = 0;
  musicNotes.forEach(n=>{
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = n.freq;
    gain.gain.value = 0.03;
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(audioCtx.currentTime + start);
    osc.stop(audioCtx.currentTime + start + n.dur);
    musicOscs.push(osc);
    osc.onended = () => {
      const i = musicOscs.indexOf(osc);
      if(i>=0) musicOscs.splice(i,1);
    };
    start += n.dur;
  });
  musicTimeout = setTimeout(scheduleMusic, start*1000);
}
function startMusic(){
  if(!musicPlaying){
    musicPlaying = true;
    scheduleMusic();
  }
}
function stopMusic(){
  musicPlaying = false;
  if(musicTimeout){
    clearTimeout(musicTimeout);
    musicTimeout = null;
  }
  musicOscs.forEach(o=>{ try { o.stop(); } catch(e) {} });
  musicOscs.length = 0;
}

muteBtn.addEventListener('click', () => {
  if(musicPlaying){
    stopMusic();
  } else {
    startMusic();
  }
  muteBtn.textContent = 'ðŸ”•';
  muteBtn.blur();
});

function playVictoryJingle(){
  const notes = [
    {freq:523, dur:0.3},
    {freq:659, dur:0.3},
    {freq:784, dur:0.6}
  ];
  let start=0;
  notes.forEach(n=>{
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type='triangle';
    osc.frequency.value=n.freq;
    gain.gain.value=0.1;
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(audioCtx.currentTime+start);
    osc.stop(audioCtx.currentTime+start+n.dur);
    start+=n.dur;
  });
}

function saveScore(name,score){
  scoreboard.push({name,score});
  scoreboard.sort((a,b)=>b.score-a.score);
  scoreboard.splice(5);
  localStorage.setItem('scoreboard', JSON.stringify(scoreboard));
}

// Star field
const stars = [];
function initStars(){
  for(let i=0;i<100;i++){
    stars.push({
      x: Math.random()*canvas.width,
      y: Math.random()*canvas.height,
      phase: Math.random()*Math.PI*2,
      speed: 0.01 + Math.random()*0.02
    });
  }
}
initStars();
// Tunable game constants (slightly slower overall)
const TURN_SPEED = 0.05;
const ACCELERATION = 0.05;
const BULLET_SPEED = 3;
const SLOWDOWN_FACTOR = 0.95; // when holding the down arrow
const ASTEROID_MIN_SPEED = 0.5;
const ASTEROID_MAX_SPEED = 1.2;
let score = 0;
let lives = 3;
let gameOver = false;
let waiting = false;
let levelComplete = false;
let gameComplete = false;
let level = 1;
let reverseHold = 0;
const ship = {x: canvas.width/2, y: canvas.height/2, angle: 0, vx:0, vy:0};
const bullets = [];
const asteroids = [];
const explosions = [];
const scoreboard = JSON.parse(localStorage.getItem('scoreboard')||'[]');
function spawnAsteroid(size=1, x=Math.random()*canvas.width, y=Math.random()*canvas.height) {
  const angle = Math.random() * Math.PI * 2;
  const speed = ASTEROID_MIN_SPEED + Math.random() * (ASTEROID_MAX_SPEED - ASTEROID_MIN_SPEED);
  asteroids.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size, emoji: asteroidEmoji });
}

function startLevel(){
  waiting = false;
  levelComplete = false;
  ship.x = canvas.width/2;
  ship.y = canvas.height/2;
  ship.vx = ship.vy = 0;
  ship.angle = 0;
  bullets.length = 0;
  asteroids.length = 0;
  for(let i=0;i<5;i++) {
    let size = 1;
    if(level===2) size = 2;
    else if(level===3) size = 3;
    spawnAsteroid(size);
  }
}
startLevel();
function playerHit(){
  lives--;
  playCrashSound();
  stopMusic();
  ship.x = canvas.width/2;
  ship.y = canvas.height/2;
  ship.vx = ship.vy = 0;
  ship.angle = 0;
  if(lives <= 0){
    gameOver = true;
  } else {
    waiting = true;
  }
}
function restartGame(){
  score = 0;
  lives = 3;
  gameOver = false;
  waiting = false;
  levelComplete = false;
  gameComplete = false;
  level = 1;
  stopMusic();
  startLevel();
}

function nextLevel(){
  level++;
  if(level>3) level=3;
  startLevel();
}
const keys = {};
document.addEventListener('keydown',e=>{
  if(audioCtx.state === 'suspended') audioCtx.resume();
  startMusic();
  keys[e.code]=true;
  if(e.code==='Enter'){
    if(gameOver){
      restartGame();
    }else if(gameComplete){
      const name = prompt('Enter your name');
      if(name) saveScore(name, score);
      restartGame();
    }else if(levelComplete){
      nextLevel();
    }else if(waiting){
      waiting=false;
    }
  }
});
document.addEventListener('keyup',e=>{keys[e.code]=false;});
function update(){
  if(gameOver || waiting || levelComplete || gameComplete) return;
  stars.forEach(s=>{s.phase+=s.speed;});
  if(keys['ArrowLeft']) ship.angle -= TURN_SPEED;
  if(keys['ArrowRight']) ship.angle += TURN_SPEED;
  if(keys['ArrowUp']) {
    ship.vx += Math.cos(ship.angle) * ACCELERATION;
    ship.vy += Math.sin(ship.angle) * ACCELERATION;
  }
  if(keys['ArrowDown']) {
    ship.vx *= SLOWDOWN_FACTOR;
    ship.vy *= SLOWDOWN_FACTOR;
    reverseHold++;
    if(reverseHold > 15) {
      ship.vx -= Math.cos(ship.angle) * ACCELERATION;
      ship.vy -= Math.sin(ship.angle) * ACCELERATION;
    }
  } else {
    reverseHold = 0;
  }
  const speed = Math.hypot(ship.vx, ship.vy);
  engineOsc.frequency.value = 100 + speed * 200;
  engineGain.gain.value = speed > 0.05 ? 0.05 : 0;
  if(keys['Space']) {
    if(!ship.shootCooldown) {
      bullets.push({ x: ship.x, y: ship.y, vx: Math.cos(ship.angle) * BULLET_SPEED, vy: Math.sin(ship.angle) * BULLET_SPEED });
      playShootSound();
      ship.shootCooldown = 10;
    }
  }
  if(ship.shootCooldown>0) ship.shootCooldown--;
  ship.x = (ship.x + ship.vx + canvas.width) % canvas.width;
  ship.y = (ship.y + ship.vy + canvas.height) % canvas.height;
  bullets.forEach((b,i)=>{
    b.x += b.vx;
    b.y += b.vy;
    if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height) bullets.splice(i,1);
  });
  for(let ai=asteroids.length-1; ai>=0; ai--){
    const a = asteroids[ai];
    a.x = (a.x+a.vx+canvas.width)%canvas.width;
    a.y = (a.y+a.vy+canvas.height)%canvas.height;
    const radius = 20 * (a.size || 1);
    for(let bi=bullets.length-1; bi>=0; bi--){
      const b = bullets[bi];
      if(Math.hypot(a.x-b.x,a.y-b.y)<radius){
        bullets.splice(bi,1);
        asteroids.splice(ai,1);
        if(level===2 && a.size===2){
          spawnAsteroid(1,a.x,a.y);
          spawnAsteroid(1,a.x,a.y);
        } else if(level===3){
          if(a.size===3){
            spawnAsteroid(2,a.x,a.y);
            spawnAsteroid(2,a.x,a.y);
            spawnAsteroid(2,a.x,a.y);
          } else if(a.size===2){
            spawnAsteroid(1,a.x,a.y);
            spawnAsteroid(1,a.x,a.y);
          }
        }
        playFartSound();
        score++;
        const frags=[];
        for(let i=0;i<5;i++){
          const ang=Math.random()*Math.PI*2;
          const spd=1+Math.random()*2;
          frags.push({x:a.x,y:a.y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd});
        }
        explosions.push({life:20,frags});
        break;
      }
    }
    if(Math.hypot(a.x-ship.x,a.y-ship.y)<radius){
      asteroids.splice(ai,1);
      playerHit();
    }
  }
  explosions.forEach((ex,i)=>{
    ex.life--;
    ex.frags.forEach(f=>{f.x+=f.vx; f.y+=f.vy;});
    if(ex.life<=0) explosions.splice(i,1);
  });
  if(!levelComplete && asteroids.length===0){
    if(level===3){
      gameComplete=true;
      stopMusic();
      playVictoryJingle();
    } else {
      levelComplete=true;
      waiting=true;
    }
  }
}
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.globalAlpha = 1;
  stars.forEach(s=>{
    const alpha = 0.5 + 0.5*Math.sin(s.phase);
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillRect(s.x, s.y, 2, 2);
  });
  ctx.fillStyle='white';
  ctx.font='30px serif';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  bullets.forEach(b=>{
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(Math.PI);
    ctx.fillText(bulletEmoji, 0, 0);
    ctx.restore();
  });
  asteroids.forEach(a=>{
    ctx.font = `${30*(a.size||1)}px serif`;
    ctx.fillText(a.emoji || asteroidEmoji, a.x, a.y);
  });
  ctx.font='20px serif';
  explosions.forEach(ex=>{
    ctx.save();
    ctx.globalAlpha = ex.life/20;
    ex.frags.forEach(f=>{
      ctx.fillText('ðŸ’©', f.x, f.y);
    });
    ctx.restore();
  });
  ctx.save();
  ctx.translate(ship.x,ship.y);
  ctx.rotate(ship.angle);
  ctx.font='30px serif';
  ctx.fillText(shipEmoji,0,0);
  ctx.restore();
  ctx.fillStyle='white';
  ctx.textAlign='left';
  ctx.fillText('Score: '+score+'  Level: '+level,10,30);
  ctx.textAlign='right';
  ctx.fillText(shipEmoji.repeat(lives),canvas.width-10,30);
  if(gameComplete){
    ctx.textAlign='center';
    ctx.fillText('Game complete - press Enter',canvas.width/2,canvas.height/2-40);
    ctx.fillText('Scoreboard:',canvas.width/2,canvas.height/2);
    scoreboard.forEach((s,i)=>{
      ctx.fillText(`${i+1}. ${s.name} - ${s.score}`,canvas.width/2,canvas.height/2+30*(i+1));
    });
  } else if(levelComplete){
    ctx.textAlign='center';
    ctx.fillText('Level complete - press Enter',canvas.width/2,canvas.height/2);
  } else if(waiting){
    ctx.textAlign='center';
    ctx.fillText('Press Enter to continue',canvas.width/2,canvas.height/2);
  }
  if(gameOver){
    ctx.textAlign='center';
    ctx.fillText('Game Over - press Enter',canvas.width/2,canvas.height/2);
  }
}
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
