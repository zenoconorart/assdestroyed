<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
<title>Emoji Asteroids</title>
<style>
  html,body{margin:0;padding:0;width:100%;height:100%;background:#000;overflow:hidden;touch-action:none;}
  canvas{display:block;width:100vw;height:100vh;background:#000;}
  #hint{position:fixed;top:8px;left:8px;color:#fff;font-family:system-ui,Segoe UI,Arial,sans-serif;font-size:14px;opacity:.7;z-index:2}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="hint">Tap to fire ‚Ä¢ Hold to thrust toward touch</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const shipEmoji = 'üçÜ';
const bulletEmoji = 'üí¶';
const asteroidEmoji = 'üçë';
const TURN_SPEED = 0.03;
const ACCELERATION = 0.015;
const BULLET_SPEED = 2.7;
const SLOWDOWN_FACTOR = 0.99;
const ASTEROID_MIN_SPEED = 0.35;
const ASTEROID_MAX_SPEED = 0.9;
const LEVELS = [
  { splits: 0, size: 24 },  // level 1 normal
  { splits: 1, size: 28 },  // level 2 slightly bigger, split once
  { splits: 2, size: 24 },  // level 3 split twice
  { splits: 3, size: 24 }   // level 4 split three times (lots of tiny ones)
];
let currentLevel = 1;
let score = 0, lives = 3, gameOver = false, waiting = false, levelComplete = false;
const ship = {x: 0, y: 0, angle: 0, vx:0, vy:0};
const bullets = [], asteroids = [], explosions = [];
function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  ship.x = canvas.width/2; ship.y = canvas.height/2;
}
window.addEventListener('resize', resize); resize();
function spawnAsteroidAt(x, y, size, splits){
  const angle = Math.random() * Math.PI * 2;
  const speed = ASTEROID_MIN_SPEED + Math.random() * (ASTEROID_MAX_SPEED - ASTEROID_MIN_SPEED);
  asteroids.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size, splits });
}
function startLevel(){
  asteroids.length = 0;
  const cfg = LEVELS[Math.min(currentLevel, LEVELS.length) - 1];
  for(let i=0;i<6;i++){
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    spawnAsteroidAt(x, y, cfg.size, cfg.splits);
  }
}
function splitAsteroid(a){
  if(a.splits<=0) return;
  const newSize = Math.max(10, a.size * 0.6);
  for(let i=0;i<2;i++){
    const offset = (Math.random()*12)-6;
    spawnAsteroidAt(a.x + offset, a.y + offset, newSize, a.splits-1);
  }
}
startLevel();
function playerHit(){
  lives--; ship.x = canvas.width/2; ship.y = canvas.height/2; ship.vx=ship.vy=0; ship.angle=0;
  if(lives<=0){ gameOver = true; } else { waiting = true; }
}
function restartGame(){
  score=0; lives=3; currentLevel=1; gameOver=false; waiting=false; levelComplete=false; ship.x=canvas.width/2; ship.y=canvas.height/2; ship.vx=ship.vy=0; ship.angle=0; bullets.length=0; startLevel();
}
function nextLevel(){
  currentLevel++; levelComplete=false; waiting=false; ship.x=canvas.width/2; ship.y=canvas.height/2; ship.vx=ship.vy=0; ship.angle=0; bullets.length=0; startLevel();
}
// Touch control state
let touchActive = false;
let target = {x:0,y:0};
function setTarget(t){ target.x = t.clientX; target.y = t.clientY; }
canvas.addEventListener('touchstart', (e)=>{
  e.preventDefault();
  const t = e.touches[0]; if(t){ setTarget(t); }
  touchActive = true;
  // fire once on tap
  if(!ship.shootCooldown){ bullets.push({ x: ship.x, y: ship.y, vx: Math.cos(ship.angle)*BULLET_SPEED, vy: Math.sin(ship.angle)*BULLET_SPEED }); ship.shootCooldown = 10; }
  if(gameOver) restartGame(); else if(levelComplete) nextLevel(); else if(waiting) waiting=false;
}, {passive:false});
canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); const t=e.touches[0]; if(t){ setTarget(t);} }, {passive:false});
canvas.addEventListener('touchend', (e)=>{ e.preventDefault(); touchActive = false; }, {passive:false});
canvas.addEventListener('touchcancel', (e)=>{ e.preventDefault(); touchActive = false; }, {passive:false});
// Keyboard
const keys = {};
document.addEventListener('keydown',e=>{ keys[e.code]=true; if(e.code==='Enter'){ if(gameOver) restartGame(); else if(levelComplete) nextLevel(); else if(waiting) waiting=false; } });
document.addEventListener('keyup',e=>{ keys[e.code]=false; });
function update(){
  if(gameOver || waiting || levelComplete) return;
  // touch thrust toward target
  if(touchActive){
    ship.angle = Math.atan2(target.y - ship.y, target.x - ship.x);
    ship.vx += Math.cos(ship.angle)*ACCELERATION;
    ship.vy += Math.sin(ship.angle)*ACCELERATION;
  }
  // keyboard fallback
  if(keys['ArrowLeft']) ship.angle -= TURN_SPEED;
  if(keys['ArrowRight']) ship.angle += TURN_SPEED;
  if(keys['ArrowUp']) { ship.vx += Math.cos(ship.angle)*ACCELERATION; ship.vy += Math.sin(ship.angle)*ACCELERATION; }
  if(keys['ArrowDown']) { ship.vx *= SLOWDOWN_FACTOR; ship.vy *= SLOWDOWN_FACTOR; }
  if(keys['Space']) { if(!ship.shootCooldown){ bullets.push({ x: ship.x, y: ship.y, vx: Math.cos(ship.angle)*BULLET_SPEED, vy: Math.sin(ship.angle)*BULLET_SPEED }); ship.shootCooldown = 10; } }
  if(ship.shootCooldown>0) ship.shootCooldown--;
  // drift slows a bit when not thrusting
  if(!touchActive && !keys['ArrowUp']){ ship.vx *= SLOWDOWN_FACTOR; ship.vy *= SLOWDOWN_FACTOR; }
  ship.x = (ship.x + ship.vx + canvas.width) % canvas.width;
  ship.y = (ship.y + ship.vy + canvas.height) % canvas.height;
  bullets.forEach((b,i)=>{ b.x += b.vx; b.y += b.vy; if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height) bullets.splice(i,1); });
  for(let ai=asteroids.length-1; ai>=0; ai--){
    const a = asteroids[ai];
    a.x = (a.x+a.vx+canvas.width)%canvas.width; a.y = (a.y+a.vy+canvas.height)%canvas.height;
    for(let bi=bullets.length-1; bi>=0; bi--){ const b = bullets[bi]; if(Math.hypot(a.x-b.x,a.y-b.y)<a.size){ bullets.splice(bi,1); asteroids.splice(ai,1); splitAsteroid(a); score++; explosions.push({x:a.x, y:a.y, life:20, size:a.size}); break; } }
    if(Math.hypot(a.x-ship.x,a.y-ship.y)<a.size){ asteroids.splice(ai,1); splitAsteroid(a); playerHit(); }
  }
  explosions.forEach((ex,i)=>{ ex.life--; if(ex.life<=0) explosions.splice(i,1); });
  if(!levelComplete && asteroids.length===0){ levelComplete=true; waiting=true; }
}
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.font='30px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  bullets.forEach(b=>ctx.fillText(bulletEmoji,b.x,b.y));
  asteroids.forEach(a=>{ ctx.font=`${Math.max(18,a.size*1.4)}px serif`; ctx.fillText(asteroidEmoji,a.x,a.y); });
  explosions.forEach(ex=>{ ctx.save(); ctx.globalAlpha=ex.life/20; ctx.fillStyle='brown'; ctx.beginPath(); ctx.arc(ex.x, ex.y, (ex.size||20) - (20-ex.life), 0, Math.PI*2); ctx.fill(); ctx.restore(); });
  ctx.font='30px serif';
  ctx.save(); ctx.translate(ship.x,ship.y); ctx.rotate(ship.angle); ctx.fillText(shipEmoji,0,0); ctx.restore();
  ctx.fillStyle='white'; ctx.textAlign='left'; ctx.fillText('Score: '+score,10,30);
  ctx.textAlign='right'; ctx.fillText(shipEmoji.repeat(lives),canvas.width-10,30);
  if(levelComplete){ ctx.textAlign='center'; ctx.fillText('Level complete - tap to continue',canvas.width/2,canvas.height/2); }
  else if(waiting){ ctx.textAlign='center'; ctx.fillText('Tap to continue',canvas.width/2,canvas.height/2); }
  if(gameOver){ ctx.textAlign='center'; ctx.fillText('Game Over - tap to restart',canvas.width/2,canvas.height/2); }
}
function loop(){ update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
